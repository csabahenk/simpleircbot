#!/usr/bin/env ruby

require 'socket'
require 'optparse'
require 'open-uri'
require 'cgi'
require 'shellwords'
require 'yaml'

class SimpleIrcBot

  def initialize(server:, port:, channel:, nick:,
                 bugzilla_url:, gerrit_url:, gerrit_user:, gerrit_port:,
                 cache_expiry:, cache_prefetch:)
    @channel = channel
    @nick = nick
    @bugzilla = bugzilla_url.sub(%r@\Ahttps?://@, "")
    @gerrit = gerrit_url.sub(%r@\Ahttps?://@, "")
    @gerrit_user = gerrit_user
    @gerrit_port = gerrit_port
    @cache = {}
    @cache_expiry = cache_expiry <= 0 ? nil : cache_expiry
    cache_prefetch.each { |token|
      service, id = token.split(":", 2)
      service = service.to_sym
      cache_fetch service, id
    }
    @socket = TCPSocket.open(server, port)
    say "NICK #{nick}"
    say "USER ircbot 0 * #{nick}"
    say "JOIN ##{@channel}"
    say_to_chan "#{1.chr}ACTION is here to help#{1.chr}"
    say_to_chan "Whenever I see {bz|bug} <bug-id>, {gerrit|review|change} <change-number|change-id|git-id> ..."
    say_to_chan "... -- or eg. BZ <bug-id> ... I don't care about case -- ..."
    say_to_chan "... or #{@bugzilla}/<bug-id>, #{@gerrit}/<change-number|change-id|git-id> ..."
    say_to_chan "... I tell it like it is!".upcase
  end

  def say(msg)
    puts msg
    @socket.puts msg
  end

  def say_to_chan(*msg)
    say "PRIVMSG ##{@channel} :#{msg.join ", "}"
  end

  def cache_get *keys
    record = @cache[keys]
    value = if record
      if @cache_expiry and Time.now - record[:time] > @cache_expiry * 3600
        cache_delete *keys
        nil
      else
        record[:value]
      end
    end
    puts "CACHE: " + if value
      "hit #{keys.inspect}" +
      if @cache_expiry
        ", valid for #{(record[:time] - Time.now).to_i/3600 + @cache_expiry} hours"
      else
        ""
      end
    else
      "miss #{keys.inspect}"
    end
    value
  end

  def cache_add value, *keys
    @cache[keys] = {value: value, time: Time.now}
    value
  end

  def cache_delete *keys
    @cache.delete keys
  end

  def cache_provide *keys
    value = cache_get *keys
    value and return value
    value = yield *keys
    cache_add value, *keys
  end

  def cache_fetch service, id
    cache_provide service, id, &method(:fetch)
  end

  def fetch service, id
    send "fetch_#{service}", id
  end

  def bugzilla_url bz
    "https://#{@bugzilla}/#{bz}"
  end

  def fetch_bugzilla bz
    title = "Bug not found :("
    open(bugzilla_url bz) {|f|
      while l=f.gets
        if l =~ %r@<title>(.*)</title>@
          # CGI.unescapeHTML does not know of ndash :/
          title = CGI.unescapeHTML $1.gsub("&ndash;", "â€“")
          break
        end
      end
    }
    title
  end

  def fetch_gerrit change
    changedata = open(
      "|ssh #{@gerrit_user.shellescape}@#{@gerrit.shellescape} -p #{@gerrit_port} " \
      "gerrit query --format=json --patch-sets #{change}", &:read)
    changeinfo = begin
      # what comes is a JSON stream, ie. concatenated JSON objects,
      # but JSON can do only a single object, so instead we use YAML
      changeinfo = YAML.load changedata
    rescue Psych::SyntaxError
    end
    case changeinfo
    when Hash
      %w[url subject commitMessage].instance_eval {
        zip(changeinfo.values_at *self).to_h
      }
    else
      changeinfo
    end
  end

  def run
    until @socket.eof? do
      msg = @socket.gets
      puts msg

      if msg.match(/^PING :(.*)$/)
        say "PONG #{$~[1]}"
        next
      end

      if msg.match(/PRIVMSG ##{@channel} :(.*)$/)
        content = $~[1]

        #put matchers here

        # Bugzilla...
        bzrx = %r@(?:#{@bugzilla}/(?:show_bug.cgi\?id=)?|(?:\A|\s)(?:bz|bug):?\s+)(\d+)@i
        process_bugzilla = proc { |bz,decor=""|
          say_to_chan decor + bugzilla_url(bz), cache_fetch(:bugzilla, bz)
        }
        content.scan(bzrx).flatten.uniq.each &process_bugzilla

        # Gerrit...
        content.scan(
          %r@(?:#{@gerrit}/(?:#/c/)?|(?:\A|\s)(?:change|review|gerrit):?\s+)(\d+|I?[\da-z]{6,})@i
        ).flatten.uniq.each { |change|
          changeinfo = cache_fetch(:gerrit, change)
          case changeinfo
          when Hash
            say_to_chan *changeinfo.values_at("url", "subject")
            changeinfo["commitMessage"].each_line {|l|
              l =~ /\A\s*#{bzrx}\s*\Z/ && process_bugzilla[$1, "`-> "]
            }
          else
            say_to_chan "#{@gerrit}: change #{change} not found"
          end
        }

      end
    end
  end

  def quit
    say "PART ##{@channel} :Daisy, Daisy, give me your answer do"
    say 'QUIT'
  end
end

OPTS = {
  bugzilla_url: String,
  gerrit_user: String,
  gerrit_port: 29418,
  gerrit_url: String,
  cache_expiry: 168,
  cache_prefetch: [],
  server: "irc.freenode.net",
  port: 6667,
  channel: String,
  nick: "batty",
}.map { |o,d| [o, [d]] }.to_h
fixer = { Fixnum => Integer }
OptionParser.new { |op|
   OPTS.each { |o,w|
     # Mangling OPTS to OptionParser options in a disgraced manner
     # - opt_name: <scalar> becomes:
     #   op.on("-o", "--opt-name", fixer[<scalar>.class], <scalar>.to_s) {...}
     #   where fixer is needed to map arbitrary classes into the class set
     #   accepted by OptionParser
     # - opt_name: <class> becomes: op.on("-o", "--opt-name", <class>) {...}
     op.on("-#{o[0]}", "--#{o.to_s.gsub "_", "-"}=VAL", *(
       (Class === w[0] ? [] : [w[0].class]) << w[0]
     ).instance_eval {|a|
         [fixer[a[0]]||a[0]] + a[1..-1].map(&:to_s)
     }) { |v| OPTS[o] << v }
   }
}.parse!
OPTS.each { |o,w|
  v = w[1] || w[0]
  if Class === v
    puts "missing value for --#{o}"
    exit 1
  end
  OPTS[o] = v
}

bot = SimpleIrcBot.new(**OPTS)

trap("INT"){ bot.quit }

bot.run
