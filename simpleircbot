#!/usr/bin/env ruby

require 'socket'
require 'optparse'

class SimpleIrcBot

  def initialize(server:, port:, channel:, nick:)
    @channel = channel
    @socket = TCPSocket.open(server, port)
    @nick = nick
    say "NICK #{nick}"
    say "USER ircbot 0 * #{nick}"
    say "JOIN ##{@channel}"
    say_to_chan "#{1.chr}ACTION is here to help#{1.chr}"
  end

  def say(msg)
    puts msg
    @socket.puts msg
  end

  def say_to_chan(msg)
    say "PRIVMSG ##{@channel} :#{msg}"
  end

  def run
    until @socket.eof? do
      msg = @socket.gets
      puts msg

      if msg.match(/^PING :(.*)$/)
        say "PONG #{$~[1]}"
        next
      end

      if msg.match(/PRIVMSG ##{@channel} :(.*)$/)
        content = $~[1]

        #put matchers here
        if content.match(/#{@nick}/)
          say_to_chan('your response')
        end
      end
    end
  end

  def quit
    say "PART ##{@channel} :Daisy, Daisy, give me your answer do"
    say 'QUIT'
  end
end

OPTS = {
  server: "irc.freenode.net",
  port: 6667,
  channel: String,
  nick: "batty"
}.map { |o,d| [o, [d]] }.to_h
fixer = { Fixnum => Integer }
OptionParser.new { |op|
   OPTS.each { |o,w|
     # Mangling OPTS to OptionParser options in a disgraced manner
     # - opt_name: <scalar> becomes:
     #   op.on("-o", "--opt-name", fixer[<scalar>.class], <scalar>.to_s) {...}
     #   where fixer is needed to map arbitrary classes into the class set
     #   accepted by OptionParser
     # - opt_name: <class> becomes: op.on("-o", "--opt-name", <class>) {...}
     op.on("-#{o[0]}", "--#{o.to_s.gsub "_", "-"}=VAL", *(
       (Class === w[0] ? [] : [w[0].class]) << w[0]
     ).instance_eval {|a|
         [fixer[a[0]]||a[0]] + a[1..-1].map(&:to_s)
     }) { |v| OPTS[o] << v }
   }
}.parse!
OPTS.each { |o,w|
  v = w[1] || w[0]
  if Class === v
    puts "missing value for --#{o}"
    exit 1
  end
  OPTS[o] = v
}

bot = SimpleIrcBot.new(**OPTS)

trap("INT"){ bot.quit }

bot.run
