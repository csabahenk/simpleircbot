#!/usr/bin/env ruby

require 'socket'
require 'optparse'
require 'open-uri'
require 'cgi'
require 'shellwords'
require 'yaml'

class SimpleIrcBot

  def initialize(server:, port:, channel:, nick:,
                 bugzilla_url:, gerrit_url:, gerrit_user:, gerrit_port:)
    @channel = channel
    @socket = TCPSocket.open(server, port)
    @nick = nick
    @bugzilla = bugzilla_url.sub(%r@\Ahttps?://@, "")
    @gerrit = gerrit_url.sub(%r@\Ahttps?://@, "")
    @gerrit_user = gerrit_user
    @gerrit_port = gerrit_port
    @cache = {}
    say "NICK #{nick}"
    say "USER ircbot 0 * #{nick}"
    say "JOIN ##{@channel}"
    say_to_chan "#{1.chr}ACTION is here to help#{1.chr}"
    say_to_chan "Whenever I see {bz|bug} <bug-id>, {gerrit|review|change} <change-number|change-id|git-id> ..."
    say_to_chan "... -- or eg. BZ <bug-id> ... I don't care about case -- ..."
    say_to_chan "... or #{@bugzilla}/<bug-id>, #{@gerrit}/<change-number|change-id|git-id> ..."
    say_to_chan "... I tell it like it is!".upcase
  end

  def say(msg)
    puts msg
    @socket.puts msg
  end

  def say_to_chan(*msg)
    say "PRIVMSG ##{@channel} :#{msg.join ", "}"
  end

  def cache_get *keys
    value = @cache[keys]
    puts "CACHE: #{value ? "hit" : "miss"} #{keys.inspect}"
    value
  end

  def cache_add value, *keys
    @cache[keys] = value
  end

  def cache_provide *keys
    value = cache_get *keys
    value and return value
    value = yield *keys
    cache_add value, *keys
  end

  def run
    until @socket.eof? do
      msg = @socket.gets
      puts msg

      if msg.match(/^PING :(.*)$/)
        say "PONG #{$~[1]}"
        next
      end

      if msg.match(/PRIVMSG ##{@channel} :(.*)$/)
        content = $~[1]

        #put matchers here

        # Bugzilla...
        bzrx = %r@(?:#{@bugzilla}/(?:show_bug.cgi\?id=)?|(?:\A|\s)(?:bz|bug):?\s+)(\d+)@i
        process_bugzilla = proc { |bz,decor=""|
          bugurl = "https://#{@bugzilla}/#{bz}"
          title = cache_provide(:bugzilla, bz) {
            title = "Bug not found :("
            open(bugurl) {|f|
              while l=f.gets
                if l =~ %r@<title>(.*)</title>@
                  # CGI.unescapeHTML does not know of ndash :/
                  title = CGI.unescapeHTML $1.gsub("&ndash;", "â€“")
                  break
                end
              end
            }
            title
          }
          say_to_chan decor + bugurl, title
        }
        content.scan(bzrx).flatten.uniq.each &process_bugzilla

        # Gerrit...
        content.scan(
          %r@(?:#{@gerrit}/(?:#/c/)?|(?:\A|\s)(?:change|review|gerrit):?\s+)(\d+|I?[\da-z]{6,})@i
        ).flatten.uniq.each { |change|
          changeinfo = cache_provide(:gerrit, change) {
            changedata = open(
              "|ssh #{@gerrit_user.shellescape}@#{@gerrit.shellescape} -p #{@gerrit_port} " \
              "gerrit query --format=json --patch-sets #{change}", &:read)
            changeinfo = begin
              # what comes is a JSON stream, ie. concatenated JSON objects,
              # but JSON can do only a single object, so instead we use YAML
              changeinfo = YAML.load changedata
            rescue Psych::SyntaxError
            end
            case changeinfo
            when Hash
              %w[url subject commitMessage].instance_eval {
                zip(changeinfo.values_at *self).to_h
              }
            else
              changeinfo
            end
          }
          case changeinfo
          when Hash
            say_to_chan *changeinfo.values_at("url", "subject")
            changeinfo["commitMessage"].each_line {|l|
              l =~ /\A\s*#{bzrx}\s*\Z/ && process_bugzilla[$1, "`-> "]
            }
          else
            say_to_chan "#{@gerrit}: change #{change} not found"
          end
        }

      end
    end
  end

  def quit
    say "PART ##{@channel} :Daisy, Daisy, give me your answer do"
    say 'QUIT'
  end
end

OPTS = {
  server: "irc.freenode.net",
  port: 6667,
  channel: String,
  nick: "batty",
  bugzilla_url: String,
  gerrit_user: String,
  gerrit_port: 29418,
  gerrit_url: String
}.map { |o,d| [o, [d]] }.to_h
fixer = { Fixnum => Integer }
OptionParser.new { |op|
   OPTS.each { |o,w|
     # Mangling OPTS to OptionParser options in a disgraced manner
     # - opt_name: <scalar> becomes:
     #   op.on("-o", "--opt-name", fixer[<scalar>.class], <scalar>.to_s) {...}
     #   where fixer is needed to map arbitrary classes into the class set
     #   accepted by OptionParser
     # - opt_name: <class> becomes: op.on("-o", "--opt-name", <class>) {...}
     op.on("-#{o[0]}", "--#{o.to_s.gsub "_", "-"}=VAL", *(
       (Class === w[0] ? [] : [w[0].class]) << w[0]
     ).instance_eval {|a|
         [fixer[a[0]]||a[0]] + a[1..-1].map(&:to_s)
     }) { |v| OPTS[o] << v }
   }
}.parse!
OPTS.each { |o,w|
  v = w[1] || w[0]
  if Class === v
    puts "missing value for --#{o}"
    exit 1
  end
  OPTS[o] = v
}

bot = SimpleIrcBot.new(**OPTS)

trap("INT"){ bot.quit }

bot.run
