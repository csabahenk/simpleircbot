#!/usr/bin/env ruby

require 'socket'
require 'open-uri'
require 'cgi'
require 'shellwords'
require 'yaml'

class SimpleIrcBot

  def initialize(server:, channel:, nick:, port: 6667,
                 bugzilla_url:, gerrit_url: ,
                 gerrit_user: nil, gerrit_port: 29418,
                 cache_expiry: 0, cache_prefetch: [])
    @server = server
    @port = port
    @channel = channel
    @nick = nick
    @bugzilla = bugzilla_url.sub(%r@\Ahttps?://@, "")
    @gerrit_user = gerrit_user
    @gerrit = gerrit_url.sub(%r@\Ahttps?://@, "")
    @gerrit_port = gerrit_port
    @cache = {}
    @cache_expiry = cache_expiry <= 0 ? nil : cache_expiry
    @cache_prefetch = cache_prefetch
  end

  def startup
    prefetch_size = @cache_prefetch.size
    @cache_prefetch.each_with_index { |token,i|
      service_tok, id = token.split(":", 2)
      service = TOKEN_MAP[service_tok]
      print "pre-fetching #{i+1}/#{prefetch_size}... "
      val = cache_fetch service, id
      if service == :gerrit and val
        j = 1
        gerrit_get_bugs(val) { |bz|
          print "pre-fetching #{i+1}:#{j}/#{prefetch_size}..."
          cache_fetch :bugzilla, bz
          j += 1
        }
      end
    }
    @socket = TCPSocket.open(@server, @port)
    say "NICK #{@nick}"
    say "USER ircbot 0 * #{@nick}"
    say "JOIN ##{@channel}"
    say_to_chan "#{1.chr}ACTION is here to help#{1.chr}"
    say_to_chan "Whenever I see references to Bugzilla bugs or Gerrit changes, like..."
    say_to_chan "... BZ 36734, gerrit:531232 ..."
    say_to_chan "... or URLs like..."
    say_to_chan " #{@bugzilla}/36734, #{@gerrit}/531232 ..."
    sleep 1
    say_to_chan " "
    say_to_chan "... I tell it like it is!".upcase
    sleep 1
    say_to_chan " "
    say_to_chan %@Please message "#{@nick}: help" to know more.@
  end

  def say(msg)
    puts msg
    @socket.puts msg
  end

  def say_to_chan(*msg)
    say "PRIVMSG ##{@channel} :#{msg.join ", "}"
  end

  def cache_get *keys, verbose: false
    record = @cache[keys]
    value = if record
      if @cache_expiry and Time.now - record[:time] > @cache_expiry * 3600
        cache_delete *keys
        nil
      else
        record[:value]
      end
    end
    verbose and puts "CACHE: " + if value
      "hit #{keys.inspect}" +
      if @cache_expiry
        ", valid for #{(record[:time] - Time.now).to_i/3600 + @cache_expiry} hours"
      else
        ""
      end
    else
      "miss #{keys.inspect}"
    end
    value
  end

  def cache_add value, *keys
    @cache[keys] = {value: value, time: Time.now}
    value
  end

  def cache_delete *keys
    @cache.delete keys
  end

  def cache_provide *keys
    value = cache_get *keys, verbose: true
    value and return value
    value = yield *keys
    cache_add value, *keys
  end

  def cache_fetch service, id
    cache_provide service, id, &method(:fetch)
  end

  def fetch service, id
    send "fetch_#{service}", id
  end

  def bugzilla_url bz
    "https://#{@bugzilla}/#{bz}"
  end

  def fetch_bugzilla bz
    title = "Bug not found :("
    open(bugzilla_url bz) {|f|
      while l=f.gets
        if l =~ %r@<title>(.*)</title>@
          # CGI.unescapeHTML does not know of ndash :/
          title = CGI.unescapeHTML $1.gsub("&ndash;", "â€“")
          break
        end
      end
    }
    title
  end

  def fetch_gerrit change
    changedata = open(
      "|ssh #{@gerrit_user.shellescape}@#{@gerrit.shellescape} -p #{@gerrit_port} " \
      "gerrit query --format=json --patch-sets #{change}", &:read)
    changeinfo = begin
      # what comes is a JSON stream, ie. concatenated JSON objects,
      # but JSON can do only a single object, so instead we use YAML
      changeinfo = YAML.load changedata
    rescue Psych::SyntaxError
    end
    case changeinfo
    when Hash
      changeinfo = %w[url subject commitMessage].instance_eval {
        zip(changeinfo.values_at *self).to_h
      }
      changeinfo.values.include? nil and changeinfo = nil
    end
    changeinfo
  end

  BUGZILLA_TOKENS = %w[bz bug bugzilla]
  def _BUGZILLA_RX
    %r@(?:#{Regexp.escape @bugzilla}/(?:show_bug.cgi\?id=)?|(?:\A|\s)(?:#{BUGZILLA_TOKENS.join "|"})[:\s]\s*)(\d+)@i
  end

  GERRIT_TOKENS = %w[change review gerrit]
  def _GERRIT_RX
    %r@(?:#{Regexp.escape @gerrit}/(?:#/c/)?|(?:\A|\s)(?:#{GERRIT_TOKENS.join "|"})[:\s]\s*)(\d+|I?[\da-f]{6,})@i
  end

  TOKEN_MAP = {bugzilla: BUGZILLA_TOKENS, gerrit: GERRIT_TOKENS}.map { |tv,ta|
    ta.map { |t| [t, tv] }
  }.inject(&:+).to_h

  def gerrit_get_bugs changeinfo
    changeinfo["commitMessage"].each_line {|l|
      if l =~ /\A\s*#{_BUGZILLA_RX}\s*\Z/
        yield $1
      end
    }
  end

  def react_to nick, content

    # bot admin/inquiry commands...
    if content =~ /\A\s*#{Regexp.escape @nick}[:,\s]\s*(\S+)\s*(.*)/i
      cmd,arg = $1.downcase,$2.strip
      case cmd
      when "forget"
        if arg == "all"
          @cache.clear
          say_to_chan "OK, I forgot everything!"
        else
          found = false
          [[_BUGZILLA_RX, :bugzilla, "BZ"],
           [_GERRIT_RX, :gerrit, "review"]
          ].each { |rx, service, token|
            content.scan(rx).flatten.uniq.each { |id|
              found = true
              cache_delete service, id
              say_to_chan "OK, I forgot about #{token} #{id}!"
            }
          }
          unless found
            say_to_chan "Hey #{nick}, I don't get what you want me to forget about."
          end
        end
      when /\A(show-?cache|cache-?show)\Z/
        # Filtering through cache_get enforces a purge of expired items
        ckeys = @cache.keys.select{ |k| cache_get *k }
        ckeys.map! { |s,i| "#{s}:#{i}" }
        # grouping cache key data (heuristically) to not to overflow message
        arr = [["OK, cached entries:"]]
        ckeys.each_with_index { |k,i|
          if i % 18 == 0 and i > 0
            if i < ckeys.size - 1
              arr.last << "..."
            end
            arr << []
          end
          arr.last << k
        }
        arr.each { |e| say_to_chan e.join(" ") }
      when "help"
        ["This is #{@nick} bot on the mission to resolve Bugzilla and Gerrit references.",
         " ",
         "Syntax:",
         %@"#{BUGZILLA_TOKENS.join "|"} <bug-id>" for Bugzilla@,
         %@"#{GERRIT_TOKENS.join "|"} <change-id>" for Gerrit.@,
         "Case does not matter and a colon separator is also accepted,",
         %@So "BZ:23432" and "Gerrit: 42355" are fine too.@,
         "URLs like #{@bugzilla}/23432 and #{@gerrit}/42355 are understood,",
         "and also variants like #{@bugzilla}/show-bug.cgi?id=23432 and",
         "#{@gerrit}/#/c/42355.",
         " ",
         "Besides the following service commands are taken:",
         %@"#{@nick}: show-cache" -- shows cached entries@,
         %@"#{@nick}: forget <bugzilla or gerrit ref>, ..." -- evicts refs from cache@,
         %@"#{@nick}: forget all" -- empty the cache@,
         %@"#{@nick}: help" -- shows this message.@,
        " ",
        "Drop stars to https://github.com/csabahenk/simpleircbot ;)"].each {|msg|
          say_to_chan msg
        }
      else
        say_to_chan "Hey #{nick}, I don't undestand command #{cmd}."
      end
      return
    end

    # Bugzilla #1...
    process_bugzilla = proc { |bz,decor=""|
      say_to_chan decor + bugzilla_url(bz), cache_fetch(:bugzilla, bz)
    }
    bugs = content.scan(_BUGZILLA_RX).flatten.uniq

    # Gerrit...
    content.scan(_GERRIT_RX).flatten.uniq.each { |change|
      changeinfo = cache_fetch(:gerrit, change)
      case changeinfo
      when Hash
        say_to_chan *changeinfo.values_at("url", "subject")
        gerrit_get_bugs(changeinfo) {|bz|
          process_bugzilla[bz, "`-> "]
          # We don't need to report this bz once more.
          bugs.delete bz
        }
      else
        say_to_chan "#{@gerrit}: change #{change} not found"
      end
    }

    # Bugzilla #2
    bugs.each &process_bugzilla
  end

  def run
    until @socket.eof? do
      msg = @socket.gets
      puts msg

      if msg.match(/^PING :(.*)$/)
        say "PONG #{$~[1]}"
        next
      end

      if msg.match(/^:([^!]+)!.*PRIVMSG ##{Regexp.escape @channel} :(.*)$/)
        #put matchers here
        react_to *$~.to_a[1..-1]
      end
    end
  end

  def quit
    say "PART ##{@channel} :Daisy, Daisy, give me your answer do"
    say 'QUIT'
  end
end


if __FILE__ == $0
  require 'optparse'

  OPTS = {
    bugzilla_url: String,
    gerrit_user: String,
    gerrit_port: 29418,
    gerrit_url: String,
    cache_expiry: 168,
    cache_prefetch: [],
    server: "irc.freenode.net",
    port: 6667,
    channel: String,
    nick: "batty",
  }.map { |o,d| [o, [d]] }.to_h
  fixer = { Fixnum => Integer }
  OptionParser.new { |op|
     OPTS.each { |o,w|
       # Mangling OPTS to OptionParser options in a disgraced manner
       # - opt_name: <scalar> becomes:
       #   op.on("-o", "--opt-name", fixer[<scalar>.class], <scalar>.to_s) {...}
       #   where fixer is needed to map arbitrary classes into the class set
       #   accepted by OptionParser
       # - opt_name: <class> becomes: op.on("-o", "--opt-name", <class>) {...}
       op.on("-#{o[0]}", "--#{o.to_s.gsub "_", "-"}=VAL", *(
         (Class === w[0] ? [] : [w[0].class]) << w[0]
       ).instance_eval {|a|
           [fixer[a[0]]||a[0]] + a[1..-1].map(&:to_s)
       }) { |v| OPTS[o] << v }
     }
  }.parse!
  OPTS.each { |o,w|
    v = w[1] || w[0]
    if Class === v
      puts "missing value for --#{o}"
      exit 1
    end
    OPTS[o] = v
  }

  bot = SimpleIrcBot.new(**OPTS)

  trap("INT"){ bot.quit }

  bot.startup
  bot.run

end
